var documenterSearchIndex = {"docs":
[{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"problemparsetter/#Setting-Initial-state-and-Parameters-of-a-problem","page":"Update parameters","title":"Setting Initial state and Parameters of a problem","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"Oftern one wants to change a subset of the initial states,u0, and a subset of parameters,p, of an ODEProblem during an optimization.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"Given u0 and p being a sequence of scalars,  and popt is a sequence of optimized parameters, which may include initial states, the following class helps updating the corresponding positions in  an ODEProblem.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"# setting up a simple example composite system and problem\nusing ModelingToolkit, DifferentialEquations, LabelledArrays\nusing MTKHelpers\nfunction samplesystem(;name,τ = 3.0, p1=1.1, p2=1.2) \n    @variables t \n    D = Differential(t) \n    sts = @variables x(t) RHS(t)             # RHS is observed\n    ps = @parameters τ=τ p1=p1 p2=p2       # parameters\n    ODESystem([ RHS  ~ p1/p2 * (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0))\n\n# setup position matching\npopt = SLVector(m₊x=0.1, m₊p1=2.1)\nps = ProblemParSetter(sys, keys(popt))\n\n# extract optimized \nget_paropt(ps, prob; label=Val(true))\n\n# update states and parameters\nprob2 = update_statepar(ps, popt, prob)\nget_paropt(ps, prob2; label=Val(true)) == popt","category":"page"},{"location":"problemparsetter/#ProblemParSetter","page":"Update parameters","title":"ProblemParSetter","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"The following type stores the necessary information, that can be queried.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"ProblemParSetter\nstatesyms\ncount_states","category":"page"},{"location":"problemparsetter/#MTKHelpers.ProblemParSetter","page":"Update parameters","title":"MTKHelpers.ProblemParSetter","text":"ProblemParSetter(state_names,par_names,popt_names) \nProblemParSetter(sys::ODESystem, popt_names; strip=false)\n\nHelps keeping track of a subset of initial states and paraemters to be optimized.\n\nArguments\n\nstate_names: Tuple or Vector of all the initial states of the problem\npar_names: all the parameters of the problem\npopt_names: the parameter/initial states to be optimized.\n\nThe states and parameters can be extracted from an ModelingToolkit.ODESystem. If strip=true, then namespaces of parameteres of a composed system are removed,  e.g. subcomp₊p becomes p.\n\n\n\n\n\n","category":"type"},{"location":"problemparsetter/#MTKHelpers.statesyms","page":"Update parameters","title":"MTKHelpers.statesyms","text":"statesyms(ps::ProblemParSetter)\nparsyms(ps::ProblemParSetter)\nparoptsyms(ps::ProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters and  optimized parameters respectively.    \n\n\n\n\n\n","category":"function"},{"location":"problemparsetter/#MTKHelpers.count_states","page":"Update parameters","title":"MTKHelpers.count_states","text":"count_states(::ProblemParSetter) \ncount_par(::ProblemParSetter) \ncount_paropt(::ProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"function"},{"location":"problemparsetter/#Updating-a-problem","page":"Update parameters","title":"Updating a problem","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"update_statepar","category":"page"},{"location":"problemparsetter/#MTKHelpers.update_statepar","page":"Update parameters","title":"MTKHelpers.update_statepar","text":"prob_new = update_statepar(ps::ProblemParSetter, popt, prob::ODEProblem) \nu0new, pnew = update_statepar(ps::ProblemParSetter, popt, u0, p)\n\nReturn an updated problem or updates states and parameters where values corresponding to positions in popt are set.\n\n\n\n\n\n","category":"function"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"Further a variant or merge is implemented to produce an updated version of an SLArray or LArray are produced given a NamedTuple of updates.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"using LabelledArrays, MTKHelpers\npopt = SLVector(L = 10.1, k_L = 1.1, k_R = 1/20.1)\npopt2 = merge(popt, (k_L = 1.2,))\npopt2.k_L == 1.2","category":"page"},{"location":"problemparsetter/#Extracting-optimized-parameters","page":"Update parameters","title":"Extracting optimized parameters","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"get_paropt","category":"page"},{"location":"problemparsetter/#MTKHelpers.get_paropt","page":"Update parameters","title":"MTKHelpers.get_paropt","text":"get_paropt(ps::ProblemParSetter, prob::ODEProblem; kwargs...)\nget_paropt(ps::ProblemParSetter, u0, p; label=Val(false))\n\nExtract the initial states and parameters corresponding to the positions that are optimized.     If both u0 and p are vectors, the result is a vector, otherwise the result is a Tuple.\n\nIf label=Val(true), then label_paropt (see label_state) is called on  the return value. The default is label=Val(false) to return plain Vectors to work smoothly with Optimizers.\n\n\n\n\n\n","category":"function"},{"location":"problemparsetter/#Labeling","page":"Update parameters","title":"Labeling","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"label_state","category":"page"},{"location":"problemparsetter/#MTKHelpers.label_state","page":"Update parameters","title":"MTKHelpers.label_state","text":"label_state(ps, u::Vector) = LArray{statesyms(ps)}(u)\nlabel_par(ps, par::Vector) = LArray{parsyms(ps)}(par)\nlabel_paropt(ps, popt::Vector) = LArray{paroptsyms(ps)}(popt)\n\nProduce a labeled version of a sequence of initial states, parameters, or optimized parameters respectively. The return type differs given the input\n\nSVector -> SLVector\nNTuple -> NamedTuple\nVector -> LArray\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"#MTKHelpers","page":"Home","title":"MTKHelpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MTKHelpers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MTKHelpers]","category":"page"},{"location":"#MTKHelpers.ProblemParSetter-Union{Tuple{allow_missing_popt}, Tuple{IT}, Tuple{NP}, Tuple{NS}, Tuple{NO}, Tuple{Tuple{Vararg{Symbol, NS}}, Tuple{Vararg{Symbol, NP}}, Tuple{Vararg{Symbol, NO}}}, Tuple{Tuple{Vararg{Symbol, NS}}, Tuple{Vararg{Symbol, NP}}, Tuple{Vararg{Symbol, NO}}, Val{allow_missing_popt}}} where {NO, NS, NP, IT, allow_missing_popt}","page":"Home","title":"MTKHelpers.ProblemParSetter","text":"ProblemParSetter(state_names,par_names,popt_names) \nProblemParSetter(sys::ODESystem, popt_names; strip=false)\n\nHelps keeping track of a subset of initial states and paraemters to be optimized.\n\nArguments\n\nstate_names: Tuple or Vector of all the initial states of the problem\npar_names: all the parameters of the problem\npopt_names: the parameter/initial states to be optimized.\n\nThe states and parameters can be extracted from an ModelingToolkit.ODESystem. If strip=true, then namespaces of parameteres of a composed system are removed,  e.g. subcomp₊p becomes p.\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.count_par-Union{Tuple{ProblemParSetter{NS, NP}}, Tuple{NP}, Tuple{NS}} where {NS, NP}","page":"Home","title":"MTKHelpers.count_par","text":"count_states(::ProblemParSetter) \ncount_par(::ProblemParSetter) \ncount_paropt(::ProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.count_paropt-Union{Tuple{ProblemParSetter{NS, NP, NO}}, Tuple{NO}, Tuple{NP}, Tuple{NS}} where {NS, NP, NO}","page":"Home","title":"MTKHelpers.count_paropt","text":"count_states(::ProblemParSetter) \ncount_par(::ProblemParSetter) \ncount_paropt(::ProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.count_states-Union{Tuple{ProblemParSetter{NS}}, Tuple{NS}} where NS","page":"Home","title":"MTKHelpers.count_states","text":"count_states(::ProblemParSetter) \ncount_par(::ProblemParSetter) \ncount_paropt(::ProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.embed_system-Tuple{Any}","page":"Home","title":"MTKHelpers.embed_system","text":"embed_system(m;name)\n\nEmbeds system m as the single component of a larger system.\n\nThen the naming of the states, parameters, observables matches the namespace of the system.\n\n#using DifferentialEquations, Plots\nfunction samplesystem(;name) \n@variables t \nD = Differential(t) \nsts = @variables x(t) RHS(t)  # RHS is observed\nps = @parameters τ       # parameters\nODESystem([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\n# note that state key is m.x, hence only m needs to be defined\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob);\nplot(sol, vars=[m.x,m.RHS])    \nplot(sol, vars=getproperty.(Ref(m),[:x, :RHS])) # access by symbols\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.get_paropt-Tuple{ProblemParSetter, SciMLBase.ODEProblem}","page":"Home","title":"MTKHelpers.get_paropt","text":"get_paropt(ps::ProblemParSetter, prob::ODEProblem; kwargs...)\nget_paropt(ps::ProblemParSetter, u0, p; label=Val(false))\n\nExtract the initial states and parameters corresponding to the positions that are optimized.     If both u0 and p are vectors, the result is a vector, otherwise the result is a Tuple.\n\nIf label=Val(true), then label_paropt (see label_state) is called on  the return value. The default is label=Val(false) to return plain Vectors to work smoothly with Optimizers.\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.label_par-Tuple{Any, Vector}","page":"Home","title":"MTKHelpers.label_par","text":"label_state(ps, u::Vector) = LArray{statesyms(ps)}(u)\nlabel_par(ps, par::Vector) = LArray{parsyms(ps)}(par)\nlabel_paropt(ps, popt::Vector) = LArray{paroptsyms(ps)}(popt)\n\nProduce a labeled version of a sequence of initial states, parameters, or optimized parameters respectively. The return type differs given the input\n\nSVector -> SLVector\nNTuple -> NamedTuple\nVector -> LArray\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.label_paropt-Tuple{Any, Vector}","page":"Home","title":"MTKHelpers.label_paropt","text":"label_state(ps, u::Vector) = LArray{statesyms(ps)}(u)\nlabel_par(ps, par::Vector) = LArray{parsyms(ps)}(par)\nlabel_paropt(ps, popt::Vector) = LArray{paroptsyms(ps)}(popt)\n\nProduce a labeled version of a sequence of initial states, parameters, or optimized parameters respectively. The return type differs given the input\n\nSVector -> SLVector\nNTuple -> NamedTuple\nVector -> LArray\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.label_state-Tuple{Any, Vector}","page":"Home","title":"MTKHelpers.label_state","text":"label_state(ps, u::Vector) = LArray{statesyms(ps)}(u)\nlabel_par(ps, par::Vector) = LArray{parsyms(ps)}(par)\nlabel_paropt(ps, popt::Vector) = LArray{paroptsyms(ps)}(popt)\n\nProduce a labeled version of a sequence of initial states, parameters, or optimized parameters respectively. The return type differs given the input\n\nSVector -> SLVector\nNTuple -> NamedTuple\nVector -> LArray\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.paroptsyms-Tuple{ProblemParSetter}","page":"Home","title":"MTKHelpers.paroptsyms","text":"statesyms(ps::ProblemParSetter)\nparsyms(ps::ProblemParSetter)\nparoptsyms(ps::ProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters and  optimized parameters respectively.    \n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.parsyms-Tuple{ProblemParSetter}","page":"Home","title":"MTKHelpers.parsyms","text":"statesyms(ps::ProblemParSetter)\nparsyms(ps::ProblemParSetter)\nparoptsyms(ps::ProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters and  optimized parameters respectively.    \n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.statesyms-Tuple{ProblemParSetter}","page":"Home","title":"MTKHelpers.statesyms","text":"statesyms(ps::ProblemParSetter)\nparsyms(ps::ProblemParSetter)\nparoptsyms(ps::ProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters and  optimized parameters respectively.    \n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.strip_namespace-Tuple{Symbol}","page":"Home","title":"MTKHelpers.strip_namespace","text":"Omit the part before the first dot\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.symbol-Tuple{SymbolicUtils.Term}","page":"Home","title":"MTKHelpers.symbol","text":"Extract the basic symbol\n\n\n\n\n\n","category":"method"},{"location":"#MTKHelpers.update_statepar-Tuple{ProblemParSetter, Any, SciMLBase.ODEProblem}","page":"Home","title":"MTKHelpers.update_statepar","text":"prob_new = update_statepar(ps::ProblemParSetter, popt, prob::ODEProblem) \nu0new, pnew = update_statepar(ps::ProblemParSetter, popt, u0, p)\n\nReturn an updated problem or updates states and parameters where values corresponding to positions in popt are set.\n\n\n\n\n\n","category":"method"}]
}
