var documenterSearchIndex = {"docs":
[{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"problemparsetter/#Setting-Initial-state-and-Parameters-of-a-problem","page":"Update parameters","title":"Setting Initial state and Parameters of a problem","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"Oftern one wants to change a subset of the initial states,u0, and a subset of parameters,p, of an ODEProblem during an optimization.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"Given u0 and p being a sequence of scalars,  and popt is a sequence of optimized parameters, which may include initial states, the following class helps updating the corresponding positions in  an ODEProblem.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"# setting up a simple example composite system and problem\nusing ModelingToolkit, DifferentialEquations, LabelledArrays\nusing MTKHelpers\nfunction samplesystem(;name,τ = 3.0, p1=1.1, p2=1.2) \n    @variables t \n    D = Differential(t) \n    sts = @variables x(t) RHS(t)             # RHS is observed\n    ps = @parameters τ=τ p1=p1 p2=p2       # parameters\n    ODESystem([ RHS  ~ p1/p2 * (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0))\n\n# setup position matching\npopt = SLVector(m₊x=0.1, m₊p1=2.1)\nps = ProblemParSetter(sys, keys(popt))\n\n# extract optimized \nget_paropt_labeled(ps, prob)\n\n# update states and parameters\nprob2 = update_statepar(ps, popt, prob)\nget_paropt_labeled(ps, prob2) == popt","category":"page"},{"location":"problemparsetter/#ProblemParSetter","page":"Update parameters","title":"ProblemParSetter","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"The following type stores the necessary information, that can be queried.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"ProblemParSetter\nstatesyms(::ProblemParSetter)\ncount_states","category":"page"},{"location":"problemparsetter/#MTKHelpers.ProblemParSetter","page":"Update parameters","title":"MTKHelpers.ProblemParSetter","text":"ProblemParSetter(state_names,par_names,popt_names) \nProblemParSetter(sys::ODESystem, popt_names; strip=false)\n\nHelps keeping track of a subset of initial states and paraemters to be optimized.\n\nArguments\n\nstate_names: Tuple or Vector of all the initial states of the problem\npar_names: all the parameters of the problem\npopt_names: the parameter/initial states to be optimized.\n\nThe states and parameters can be extracted from an ModelingToolkit.ODESystem. If strip=true, then namespaces of parameteres of a composed system are removed,  e.g. subcomp₊p becomes p.\n\n\n\n\n\n","category":"type"},{"location":"problemparsetter/#MTKHelpers.statesyms-Tuple{ProblemParSetter}","page":"Update parameters","title":"MTKHelpers.statesyms","text":"statesyms(ps::ProblemParSetter)\nparsyms(ps::ProblemParSetter)\nparoptsyms(ps::ProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters and  optimized parameters respectively.    \n\n\n\n\n\n","category":"method"},{"location":"problemparsetter/#MTKHelpers.count_states","page":"Update parameters","title":"MTKHelpers.count_states","text":"count_states(::ProblemParSetter) \ncount_par(::ProblemParSetter) \ncount_paropt(::ProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"function"},{"location":"problemparsetter/#Updating-a-problem","page":"Update parameters","title":"Updating a problem","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"update_statepar","category":"page"},{"location":"problemparsetter/#MTKHelpers.update_statepar","page":"Update parameters","title":"MTKHelpers.update_statepar","text":"prob_new = update_statepar(ps::ProblemParSetter, popt, prob::ODEProblem) \nu0new, pnew = update_statepar(ps::ProblemParSetter, popt, u0, p)\n\nReturn an updated problem or updates states and parameters where values corresponding to positions in popt are set.\n\n\n\n\n\n","category":"function"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"Further a variant or merge is implemented to produce an updated version of an SLArray or LArray are produced given a NamedTuple of updates.","category":"page"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"using LabelledArrays, MTKHelpers\npopt = SLVector(L = 10.1, k_L = 1.1, k_R = 1/20.1)\npopt2 = merge(popt, (k_L = 1.2,))\npopt2.k_L == 1.2","category":"page"},{"location":"problemparsetter/#Extracting-optimized-parameters","page":"Update parameters","title":"Extracting optimized parameters","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"get_paropt","category":"page"},{"location":"problemparsetter/#MTKHelpers.get_paropt","page":"Update parameters","title":"MTKHelpers.get_paropt","text":"get_paropt(ps::ProblemParSetter, prob::ODEProblem; kwargs...)\nget_paropt(ps::ProblemParSetter, u0, p)\n\nget_paropt_labeled(ps::ProblemParSetter, prob::ODEProblem; kwargs...)\nget_paropt_labeled(ps::ProblemParSetter, u0, p)\n\nExtract the initial states and parameters corresponding to the positions that are optimized.     If both u0 and p are vectors, the result is a vector, otherwise the result is a Tuple.\n\nThe lebeled versions additionally call `labelparopt(see [label_state`](@ref))  on the return value.\n\n\n\n\n\n","category":"function"},{"location":"problemparsetter/#Labeling","page":"Update parameters","title":"Labeling","text":"","category":"section"},{"location":"problemparsetter/","page":"Update parameters","title":"Update parameters","text":"label_state","category":"page"},{"location":"problemparsetter/#MTKHelpers.label_state","page":"Update parameters","title":"MTKHelpers.label_state","text":"label_state(ps, u::Vector) = LArray{statesyms(ps)}(u)\nlabel_par(ps, par::Vector) = LArray{parsyms(ps)}(par)\nlabel_paropt(ps, popt::Vector) = LArray{paroptsyms(ps)}(popt)\n\nProduce a labeled version of a sequence of initial states, parameters, or optimized parameters respectively. The return type differs given the input\n\nSVector -> SLVector\nNTuple -> NamedTuple\nVector -> LArray\n\n\n\n\n\n","category":"function"},{"location":"cairomakie/","page":"CairoMakie Helpers","title":"CairoMakie Helpers","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"cairomakie/#CairoMakie-plotting-utils","page":"CairoMakie Helpers","title":"CairoMakie plotting utils","text":"","category":"section"},{"location":"cairomakie/","page":"CairoMakie Helpers","title":"CairoMakie Helpers","text":"pdf_figure\nseries_sol!","category":"page"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"embed_system/#Representing-a-system-as-a-component","page":"Embedding a system","title":"Representing a system as a component","text":"","category":"section"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"embed_system","category":"page"},{"location":"embed_system/#MTKHelpers.embed_system","page":"Embedding a system","title":"MTKHelpers.embed_system","text":"embed_system(m;name)\n\nEmbeds system m as the single component of a larger system. This helps to match the naming of the states, parameters, observables to  the namespace of the system. \n\nusing ModelingToolkit, DifferentialEquations\nusing MTKHelpers\nfunction samplesystem(;name) \n    @variables t \n    D = Differential(t) \n    sts = @variables x(t) RHS(t)  # RHS is observed\n    ps = @parameters τ       # parameters\n    ODESystem([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\n\n# note that keys are `m.x`,`m.τ` or `m.RHS`.\n# Hence only m needs to be defined rather than all the states, parameters, \n# and observables of the system.\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob);\ndx1 = sol[m.RHS][1:3] \ndx2 = sol[getproperty(m,:RHS)][1:3]  # access by symbols\n\n# using Plots\n# plot(sol, vars=[m.x,m.RHS])    \n# plot(sol, vars=getproperty.(Ref(m),[:x, :RHS])) # access by symbols\nlength(dx2) == 3\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#Utilities","page":"Embedding a system","title":"Utilities","text":"","category":"section"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"symbol\nstrip_namespace\nstatesyms(::ODESystem)\ncm2inch","category":"page"},{"location":"embed_system/#MTKHelpers.symbol","page":"Embedding a system","title":"MTKHelpers.symbol","text":"symbol(t)\n\nExtract the inner symbol from a Term or Num object.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#MTKHelpers.strip_namespace","page":"Embedding a system","title":"MTKHelpers.strip_namespace","text":"strip_namespace(s)\n\nOmit the part before the first dot.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#MTKHelpers.statesyms-Tuple{ModelingToolkit.ODESystem}","page":"Embedding a system","title":"MTKHelpers.statesyms","text":"statesyms(sys::ODYSystem)\nparsyms(sys::ODYSystem)\n\nExtract the basic symbols without namespace of system states and system parameters.\n\n\n\n\n\n","category":"method"},{"location":"embed_system/#MTKHelpers.cm2inch","page":"Embedding a system","title":"MTKHelpers.cm2inch","text":"cm2inch(x)\n\nConvert length in cm to inch units: 1 inch = 2.54 cm.\n\n\n\n\n\n","category":"function"},{"location":"zindex/","page":"index","title":"index","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"zindex/#Index","page":"index","title":"Index","text":"","category":"section"},{"location":"zindex/","page":"index","title":"index","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"#MTKHelpers","page":"Home","title":"MTKHelpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MTKHelpers.","category":"page"},{"location":"smoothstep/","page":"Smooth steps","title":"Smooth steps","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"smoothstep/#Smooth-steps","page":"Smooth steps","title":"Smooth steps","text":"","category":"section"},{"location":"smoothstep/","page":"Smooth steps","title":"Smooth steps","text":"ODE solvers have a hard time with step changes, where the derivative changes discontinuously. The following functin help to avoid associated problems by approximating the step by a smoother function. Argument dx controls the  smoothness.","category":"page"},{"location":"smoothstep/","page":"Smooth steps","title":"Smooth steps","text":"smoothstep","category":"page"},{"location":"smoothstep/#MTKHelpers.smoothstep","page":"Smooth steps","title":"MTKHelpers.smoothstep","text":"smoothstep(x, x_step, dx, a=zero(x), b=one(x))\n\nsmooth step function: \n\n= a for x <= x_step - dx\n= b for x >= x_step + dx\n= (a-b)/2 for x == x_step\n\nand smooth in between.\n\n\n\n\n\n","category":"function"}]
}
