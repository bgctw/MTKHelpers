var documenterSearchIndex = {"docs":
[{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"pde_dev/#PDE-support-developer-notes","page":"PDE support","title":"PDE support developer notes","text":"","category":"section"},{"location":"pde_dev/#Depth-distributions","page":"PDE support","title":"Depth distributions","text":"","category":"section"},{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"The inputs to the system have to be described by a differential across depth. The following derivation provides an exponential function f(zb) = a e^bz, such that int_z_m^0 f(z) dz = 1. Such a function can be used to distribute total inputs across depth.","category":"page"},{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"Derivation: for positive x = -z:","category":"page"},{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"beginaligned\nf(x) = a e^-bx\n\nF(x) = fraca-b e^-bx \n\nleft F(x) right_0^x_m = fraca-b left( e^-b x_m -1 right) = 1\n\na = fracb1 - e^-bx_m\n\nf(x) = fracb1 - e^-bx_m e^-bx\n\nF(x) = frac1e^-bx_m - 1 left( e^-bx -1 right)\nendaligned","category":"page"},{"location":"pde_dev/","page":"PDE support","title":"PDE support","text":"For functions and figures see Exponential depth distribution of inputs.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"concrete_parupdater/#Concrete-ProblemUpdater","page":"Type inference","title":"Concrete ProblemUpdater","text":"","category":"section"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"The default-implementations of ODEParSetter and ParUpdater do not store much information in type parameters to avoid long compilation times.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"The disadvantage is, that the result of some operations is not fully type- inferred, especially when dealing with ComponentArrays that store information in their type signature. The results of the folloginw calls are not inferred (x is stands in for either state, par, or paropt):","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"axis_x(pset)\nlabel_x(pset, ...) \nget_paropt(pset, ...), and get_paropt_labeled(pset, ...)\nupdate_statepar and remake\ncount_x(pset) is inferred but no known at compile time and   can not be used to create StaticArrays","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"Therefore, this package provides function get_concrete, that provides a concrete-typed version of a type.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"get_concrete","category":"page"},{"location":"concrete_parupdater/#MTKHelpers.get_concrete","page":"Type inference","title":"MTKHelpers.get_concrete","text":"get_concrete(pset::AbstractProblemParSetter)\nget_concrete(pu::AbstractParameterUpdater)\n\nReturn a concrete-type-version of an ProblemParSetter or ProblemUpdater.\n\n\n\n\n\n","category":"function"},{"location":"concrete_parupdater/#Example","page":"Type inference","title":"Example","text":"","category":"section"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"The following example demonstrates, how to construct a cost function that is based on a closure in which the types are inferred.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"First, lets setup a small example problem","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"using OrdinaryDiffEq, ComponentArrays, MTKHelpers, Test    \n\nf = (u, p, t) -> p[1] * u\nu0 = (L = 1 / 2,)\np = (k_L = 1.0, k_R = 2.0, k_P = 3.0)\ntspan = (0.0, 1.0)\n#prob = ODEProblem(f,SVector(Tuple(u0)),tspan,SVector(Tuple(p))) # SVector broken\nprob = ODEProblem(f, collect(u0), tspan, collect(p))\nnothing # hide","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"Updating a problem with the default ProblemUpdater results in a non-type inferred problem.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"mapping = (:k_L => :k_R, :k_L => :k_P)\npg = KeysProblemParGetter(mapping, keys(u0)) \npu = get_ode_problemupdater(pg, keys(u0), keys(p))\nprob2 = pu(prob) # not inferred\nnothing # hide","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"But we can use get_concrete to obtain a type-inferred version. ","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"puc1 = get_concrete(pu)\nprob3 = @inferred puc1(prob)\nnothing # hide","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"This can be used to create a closure for a cost function that uses the type-stable variant.","category":"page"},{"location":"concrete_parupdater/","page":"Type inference","title":"Type inference","text":"# get a concrete-type version of the ProblemParSetter and pass it \n# through a function barrier to a closure (function within let)\nget_fopt = (puc=get_concrete(pu)) -> let puc=puc\n    (prob) -> begin\n        prob_upd = @inferred puc(prob)\n    end # fopt function\nend # let, get_fopt\nfopt = get_fopt()\nprob4 = @inferred fopt(prob)\nnothing # hide","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"system_num_dict/#Translating-symbols-and-Nums","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"","category":"section"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"ModelingToolkit constructs and AbstractODEProblem from an ODESystem by supplying  Dictionaries that map Nums to values.  However, it is more convenient to store initial states and parameters as ComponentVectors with symbolic keys, instead of Dictionaries with Num keys.","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"First, lets create an example system that can demonstrate symbolic arrays in states and  parameters.","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"# setting up a simple example composite system and problem\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nfunction samplesystem_vec(; name, τ = 3.0, i=0.1, p = [1.1, 1.2, 1.3])\n    n_comp = 2\n    @parameters t\n    D = Differential(t)\n    @variables x(..)[1:n_comp] \n    ps = @parameters τ=τ i=i p[1:3]=p \n    sts = [x(t)[i] for i in 1:n_comp]\n    eq = [\n        D(x(t)[1]) ~ i - p[1] * x(t)[1] + (p[2] - x(t)[1]^2) / τ, \n        D(x(t)[2]) ~ i - p[3] * x(t)[2], \n     ]\n     ODESystem(eq, t, sts, vcat(ps...); name)\nend\n@named m = samplesystem_vec()\n@named sys = embed_system(m)\nnothing # hide","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"Next, we want to create the problem and need to specify the initial states and parameters as Dictionaries Num -> value. However, the Nums are only  defined within above function samplesystem_vec().","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"MTKHelpers provides method system_num_dict.","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"# setup initial conditions and parameters as ComponentVectors\nu0 = ComponentVector(m₊x=[0.1, 0.2])\np = ComponentVector(m₊p=[2.1, 2.2, 2.3], m₊τ = 3.1) # keep i to default\n\n# convert to Dict(Num -> value) in order to create the AbstractODEProblem\np_numdict = system_num_dict(p, sys)\nu0_numdict = system_num_dict(u0, sys)\nprob = ODEProblem(sys, u0_numdict, (0,2), p_numdict);\n\n# check the parameters of the created problem\npset = ODEProblemParSetterConcrete(sys, ComponentVector()) \np_prob = label_par(pset, prob.p)\np_prob.m₊i == 0.1     # from default\np_prob.m₊τ == p.m₊τ   # from p\np_prob.m₊p == p.m₊p   # from p","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"MTKHelpers provides a remake variant with a ODEProblemParSetter,  that allows to set u0 and p of an AbstractODEProblem by providing a ComponentVector of parameters or initial states. ","category":"page"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"paropt = ComponentVector(state=(m₊x=[10.1,10.2],), par=(m₊τ = 10.1,))\npset = ODEProblemParSetter(get_system(prob), paropt)\nprob2 = remake(prob, paropt, pset)\np2_prob = label_par(pset, prob2.p); u2_prob = label_state(pset, prob2.u0)\np2_prob.m₊τ == paropt.par.m₊τ     # from paropt\nu2_prob.m₊x == paropt.state.m₊x   # from paropt\np2_prob.m₊p == p_prob.m₊p         # from original prob\nnothing # hide","category":"page"},{"location":"system_num_dict/#API","page":"Translating symbols and Nums","title":"API","text":"","category":"section"},{"location":"system_num_dict/","page":"Translating symbols and Nums","title":"Translating symbols and Nums","text":"system_num_dict\nget_system\nbase_num\nget_base_num_dict","category":"page"},{"location":"system_num_dict/#MTKHelpers.system_num_dict","page":"Translating symbols and Nums","title":"MTKHelpers.system_num_dict","text":"system_num_dict(d, sys::AbstractSystem)\nsystem_num_dict(d, symbol_dict::AbstractDict)\n\nCreate a Dictionary Num=>value from symbolic Dictionary or ComponentVector.\n\nOmit pairs where no Num was found.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict/#MTKHelpers.get_system","page":"Translating symbols and Nums","title":"MTKHelpers.get_system","text":"get_system(prob::AbstractODEProblem)\n\nGet the System associated to a problem.\n\n\n\n\n\n","category":"function"},{"location":"system_num_dict/#MTKHelpers.base_num","page":"Translating symbols and Nums","title":"MTKHelpers.base_num","text":"base_num(s)\n\nGet the symbol without an index, e.g. p[1] -> p, or x(t)[1] -> x(t).   \n\n\n\n\n\n","category":"function"},{"location":"system_num_dict/#MTKHelpers.get_base_num_dict","page":"Translating symbols and Nums","title":"MTKHelpers.get_base_num_dict","text":"get_base_num_dict(nums)\n\nReturn a Dictionary of Symbol -> Num, for each unique base_num.(nums)\n\n\n\n\n\n","category":"function"},{"location":"cairomakie/","page":"CairoMakie Helpers","title":"CairoMakie Helpers","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"cairomakie/#CairoMakie-plotting-utils","page":"CairoMakie Helpers","title":"CairoMakie plotting utils","text":"","category":"section"},{"location":"cairomakie/","page":"CairoMakie Helpers","title":"CairoMakie Helpers","text":"series_sol!","category":"page"},{"location":"cairomakie/#MTKHelpers.series_sol!","page":"CairoMakie Helpers","title":"MTKHelpers.series_sol!","text":"series_sol!(ax, sol::AbstractODESolution, vars; tspan=extrema(sol.t), labels=string.(vars), nt=120, kwargs...)\n\ncalls CairoMakie.series for a grid of n points and interpolated values from sol. vars is passed to the solution object and can contain observables. Currently works only with solutions created by a non-composite solver, e.g. Tsit5.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"embed_system/#Representing-a-system-as-a-component","page":"Embedding a system","title":"Representing a system as a component","text":"","category":"section"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"embed_system","category":"page"},{"location":"embed_system/#MTKHelpers.embed_system","page":"Embedding a system","title":"MTKHelpers.embed_system","text":"embed_system(m;name)\n\nEmbeds system m as the single component of a larger system. This helps to match the naming of the states, parameters, observables to  the namespace of the system. \n\nusing ModelingToolkit, OrdinaryDiffEq\nusing MTKHelpers\nfunction samplesystem(;name) \n    @variables t \n    D = Differential(t) \n    sts = @variables x(t) RHS(t)  # RHS is observed\n    ps = @parameters τ       # parameters\n    ODESystem([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\n\n# note that keys are `m.x`,`m.τ` or `m.RHS`.\n# Hence only m needs to be defined rather than all the states, parameters, \n# and observables of the system.\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob, Tsit5());\ndx1 = sol[m.RHS][1:3] \ndx2 = sol[getproperty(m,:RHS)][1:3]  # access by symbols\n\n# using Plots\n# plot(sol, vars=[m.x,m.RHS])    \n# plot(sol, vars=getproperty.(Ref(m),[:x, :RHS])) # access by symbols\nlength(dx2) == 3\n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#Overriding-equations-of-an-existing-system","page":"Embedding a system","title":"Overriding equations of an existing system","text":"","category":"section"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"For debugging bigger systems, it is helful to set some equations to zero or modify/simplify the system in other ways.","category":"page"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"Function override_system takes a set of equations and matches the right-hand site to the equations of the original system and replaces those equations.","category":"page"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"# setting up a simple example composite system and problem\nusing ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nfunction samplesystem(;name,τ = 3.0, p1=1.1, p2=1.2) \n    @variables t \n    D = Differential(t) \n    sts = @variables x(t) RHS(t)             # RHS is observed\n    ps = @parameters τ=τ p1=p1 p2=p2       # parameters\n    ODESystem([ RHS  ~ p1/p2 * (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n\n# simplify the system by setting RHS ~ RHS_0 * x\nfunction samplesystem_const(RHS0; name) \n    # demonstrating override_system by setting the RHS to constant first order rate\n    m = samplesystem(;name)\n    @unpack RHS,x = m\n    @parameters t \n    ps = @parameters RHS_0=RHS0\n    D = Differential(t)\n    eqs = [\n        RHS ~ RHS_0 * x,\n    ]\n    sys_ext = override_system(eqs, m; name, ps) \nend  \n\n@named mc = samplesystem_const(-0.1)\n@named sys = embed_system(mc)\nprob = ODEProblem(sys, [mc.x => 1.0], (0.0,10.0))\nsol = solve(prob, Tsit5())\nisapprox(sol(8)[1], exp(-0.1*8), atol = 1e-5)","category":"page"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"override_system","category":"page"},{"location":"embed_system/#MTKHelpers.override_system","page":"Embedding a system","title":"MTKHelpers.override_system","text":"override_system(eqs, basesys::AbstractSystem; \n    name::Symbol=Symbol(string(nameof(basesys))*\"_ext\"), \n    ps=Term[], \n    obs=Equation[], \n    evs=ModelingToolkit.SymbolicContinuousCallback[], \n    defs=Dict()\n)\n\nModify basesys by replacing some equations matched by their left-hand-side. The keyword argument correspond to ODESystem.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#Utilities","page":"Embedding a system","title":"Utilities","text":"","category":"section"},{"location":"embed_system/","page":"Embedding a system","title":"Embedding a system","text":"symbol_op\nstrip_namespace","category":"page"},{"location":"embed_system/#MTKHelpers.symbol_op","page":"Embedding a system","title":"MTKHelpers.symbol_op","text":"symbol_op(t)\n\nExtract the inner symbol_op from a Term, Num, or BasicSymbolic object.\n\n\n\n\n\n","category":"function"},{"location":"embed_system/#MTKHelpers.strip_namespace","page":"Embedding a system","title":"MTKHelpers.strip_namespace","text":"strip_namespace(s)\n\nOmit the part before the first dot.\n\n\n\n\n\n","category":"function"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"pde/#PDE-support","page":"PDE support","title":"PDE support","text":"","category":"section"},{"location":"pde/#Exponentially-increasing-grid","page":"PDE support","title":"Exponentially increasing grid","text":"","category":"section"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"grid_exp","category":"page"},{"location":"pde/#MTKHelpers.grid_exp","page":"PDE support","title":"MTKHelpers.grid_exp","text":"grid_exp(n, z_m, efold)\n\nGenerate a Vector of n gridpoints spanning 0z_m with exponentially increasing distances. The larger the e-foling time, the sparser are the points near z_m.\n\n\n\n\n\n","category":"function"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"using MTKHelpers, Plots\nn = 16\nz_m = 0.3\nscatter(grid_exp(n, z_m, 2), label=\"efold=2\");\nscatter!(grid_exp(n, z_m, 4), label=\"efold=4\") ","category":"page"},{"location":"pde/#Exponential-depth-distribution-of-inputs","page":"PDE support","title":"Exponential depth distribution of inputs","text":"","category":"section"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"The inputs to the 1D PDE system have to be described by an unnormalized density. The following function decreases exponentially from zero to x = -z with with an integral of 1. It can be used to distribute the total input across the domain.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"Dz_exp\nDz_lin","category":"page"},{"location":"pde/#MTKHelpers.Dz_exp","page":"PDE support","title":"MTKHelpers.Dz_exp","text":"Dz_exp(x,x_m,b)\nIz_exp(x,x_m,b)\n\nDensity function decreasing exponentially from zero with e-folding time b  x in 0x_m for x_m  0 for which the intral int_0^x_m  = 1.\n\n\n\n\n\n","category":"function"},{"location":"pde/#MTKHelpers.Dz_lin","page":"PDE support","title":"MTKHelpers.Dz_lin","text":"Dz_lin(z,z_m)\nIz_lin(z,z_m)\n\nConstant density for which int_0^z_m  = 1.\n\n\n\n\n\n","category":"function"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"For its derivation see PDE support developer notes.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"The following figure displays the density for several e-folding times.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"using MTKHelpers, Plots\nx_m = 2.0\ndx = 0.1\nx_grid = 0:dx:x_m\nIz_exp(x_m, x_m, 0.5) == 1\n# Check by approximating the integral by sum\nIz_emp(x, x_m, args...; dx=1e-3) = sum(x_i -> Dz_exp(x_i,x_m,args...)*dx, 0:dx:x)\nisapprox(Iz_emp(x_m, x_m, 2), 1; atol=1e-2)\nplot(;ylab=\"depth x (m)\", xlab=\"∂/∂x\", yflip=true);\nplot!(Dz_exp.(x_grid, x_m, 0.5), x_grid, label=\"b = 0.5\");\nplot!(Dz_exp.(x_grid, x_m, 1), x_grid, label=\"b=1.0\");\nplot!(Dz_exp.(x_grid, x_m, 2), x_grid, label=\"b=2.0\")","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"And the following figure shows the corresponding integral.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"plot(;ylab=\"depth x (m)\", xlab=\"integral input from 0 to x_m\", yflip=true);\nplot!(Iz_exp.(x_grid, x_m, 0.5), x_grid, label=\"b = 0.5\");\nplot!(Iz_exp.(x_grid, x_m, 2), x_grid, label=\"b=2.0\")","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"For negative z, these functions can be used with the minus sign","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"z_m = -2\ndz = 0.1\nz_grid = z_m:dz:0\nIz_exp(-z_m, -z_m, 0.5) == 1\nplot(;ylab=\"depth z (m)\", xlab=\"di/dz\");\nplot!(Dz_exp.(-z_grid, -z_m, 0.5), z_grid, label=\"b = 0.5\");\nplot!(Dz_exp.(-z_grid, -z_m, 1), z_grid, label=\"b=1.0\");\nplot!(Dz_exp.(-z_grid, -z_m, 2), z_grid, label=\"b=2.0\")","category":"page"},{"location":"pde/#Extracting-grid-information-from-the-system-or-problem","page":"PDE support","title":"Extracting grid information from the system or problem","text":"","category":"section"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"The following require MethodOfLines to be loaded to activate the extension.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"get_1d_grid\nget_1d_state_pos\nget_discrete_space","category":"page"},{"location":"pde/#MTKHelpers.get_1d_grid","page":"PDE support","title":"MTKHelpers.get_1d_grid","text":"get_1d_grid(prob::AbstractODEProblem)\n\nGet spatial grid of a discretized 1-D PDESystem associated with a problem.\n\n\n\n\n\n","category":"function"},{"location":"pde/#MTKHelpers.get_1d_state_pos","page":"PDE support","title":"MTKHelpers.get_1d_state_pos","text":"get_1d_state_pos(sys::AbstractSystem)\n\nGet the indices of states in the grid of a discretized 1-D PDESystem  associated with a problem. It excludes the positions computed based on boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"pde/#MTKHelpers.get_discrete_space","page":"PDE support","title":"MTKHelpers.get_discrete_space","text":"get_discrete_space(prob::AbstractODEProblem) \nget_discrete_space(sys::AbstractSystem)\n\nGet the MethodOfLines.DiscreSpace object associated to the system or problem.\n\n\n\n\n\n","category":"function"},{"location":"pde/#Example-pde","page":"PDE support","title":"Example pde","text":"","category":"section"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"Define the system, here with using a non-homogeneous grid (grid_exp)  and using symbolic array parameters.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"using OrdinaryDiffEq, ModelingToolkit, DomainSets\nusing MethodOfLines\nusing MTKHelpers\nusing LoggingExtras # hide\n\n@parameters t z \nz_m = +0.3 # maximum depth in m, change to positive depth\nn_z = 16\n#z_grid = collect(range(0,z_m, length=n_z))\nz_grid = grid_exp(n_z, z_m, 3.0) \ndz = z_m/(n_z-1) # control of same grid represented by a single number\ndiscretization = MOLFiniteDifference([z => z_grid], t;\n    advection_scheme = UpwindScheme(), approx_order = 2)\n\n@parameters k_Y Y0 i_Y ω i_Y_agr[1:2] \n@variables Y(..) i_Yo(..) adv_Yo(..) dec_Y(..) Y_t(..) Y_zz(..) Yi(..) i_Yi(..) Y_z(..) adv_Yi(..) \n∂_t = Differential(t)\n∂_z = Differential(z)\n\nz_min = 0.0  # directly using 0.0 in Integral causes error in solution wrapping\nIz = Integral(z in DomainSets.ClosedInterval(z_min, z))\n\neqs0 = [\n    ∂_t(Y(t, z)) ~ Y_t(t, z),\n    Y_t(t, z) ~ i_Yo(t, z) - dec_Y(t, z) + adv_Yo(t, z),\n    #i_Yo(t, z) ~ i_Yz(t, z, i_Y),         # observable input Y specified below\n    dec_Y(t, z) ~ k_Y * Y(t, z),          # observable of decomposition \n    #adv_Yo(t, z) ~ -ω * ∂_z(Y(t, z)),  # observable advective flux of Y\n    adv_Yo(t, z) ~ -ω * ∂_z(Y(t, z)),  # observable advective flux of Y\n    # further observables that are not used in eqs\n    Y_z(t, z) ~ ∂_z(Y(t, z)),\n    Yi(t, z) ~ Iz(Y(t, z)),\n    i_Yi(t, z) ~ Iz(i_Yo(t, z)), # integral over litter inputs to check\n    adv_Yi(t,z) ~ Iz(adv_Yo(t, z)), # integral over advection inputs\n]","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"The below-ground inputs decrease exponentially with depth using Dz_exp.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"The above-ground input is specified as a function with a baseline and a pulse at t=80 and connected to the model by a Dirichlet boundary conditions.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"The initial values are specified constant across depth using Dz_lin.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"i_Yz(t,z,i_Y) = Dz_exp(z, z_m,4.0) * i_Y  \n#@register_symbolic i_Yz(t, z, i_Y)\n\neqs = vcat(eqs0, [\n    i_Yo(t, z) ~ i_Yz(t, z, i_Y),         # observable input Y\n])\n\nfgauss(x, μ, σ2) = 1/sqrt(2*pi*σ2) * exp(-(x-μ)^2/(2*σ2))\nfagr(t, i_Y_agr, i_Y_agr_pulse) = i_Y_agr + i_Y_agr_pulse*fgauss(t, 80, 2^2)\n#@register_symbolic fagr(t, i_Y_agr, i_Y_agr_pulse)\n\nbcs = [\n    Y(0, z) ~ Dz_lin(z, z_m) * Y0, # initial constant with depth,\n    ω * Y(t, 0) ~ fagr(t,i_Y_agr[1], i_Y_agr[2]), # specified flux at upper boundary\n    ∂_z(Y(t, z_m)) ~ 0, # negligible change in concentration at lower boundary\n    #\n    # following are only necessary because observables boundaries \n    # need to be specified with vector grid\n    ∂_z(dec_Y(t, 0)) ~ 0.0, \n    ∂_z(dec_Y(t, z_m)) ~ 0.0, \n    ∂_z(i_Yo(t, 0)) ~ 0.0, \n    ∂_z(i_Yo(t, z_m)) ~ 0.0, \n    #∂_z(adv_Yo(t, 0)) ~ 0.0, \n    ω * adv_Yo(t, 0) ~ fagr(t,i_Y_agr[1], i_Y_agr[2]), \n    ∂_z(adv_Yo(t, z_m)) ~ 0.0, \n    ∂_z(Y_t(t, 0)) ~ 0.0, \n    ∂_z(Y_t(t, z_m)) ~ 0.0, \n    ∂_z(Yi(t, 0)) ~ 0.0, \n    ∂_z(Yi(t, z_m)) ~ 0.0, \n    ∂_z(i_Yi(t, 0)) ~ 0.0, \n    ∂_z(i_Yi(t, z_m)) ~ 0.0, \n    ∂_z(Y_z(t, 0)) ~ 0.0, \n    ∂_z(Y_z(t, z_m)) ~ 0.0, \n    ∂_z(adv_Yi(t, 0)) ~ 0.0, \n    ∂_z(adv_Yi(t, z_m)) ~ 0.0, \n    ]\n\n# Space and time domains\ndomains = [t ∈ Interval(0.0, 500.0), z ∈ Interval(0.0, z_m), ]\n\n# PDE system\nstate_vars = [Y(t, z), i_Yo(t,z), adv_Yo(t,z), dec_Y(t,z), Y_t(t,z), Yi(t,z), i_Yi(t,z), Y_z(t,z), adv_Yi(t,z) ]\nparams = [\n        k_Y => 2.0,\n        Y0 => 200.0,\n        i_Y => 50.0,\n        ω => 0.01,\n        i_Y_agr[1] => 10.0, # base input\n        i_Y_agr[2] => 50.0, # pulse at t=80       \n]\npdesys, prob = LoggingExtras.withlevel(Logging.Error) do \n    @named pdesys = PDESystem(eqs, bcs, domains, [t, z], state_vars, params)\n    prob = discretize(pdesys, discretization) \n    pdesys, prob\nend; \nnothing # hide","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"Inside a cost function one wants to modify the parameters and initial states of the problem without the need to reconstruct the problem from the system.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"New parameters can be conveniently specified by a ComponentVector of only those components that need to be updated.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"The new initial states must be computed at the grid positions of states, i.e. at grid positions that are not at the boundary. Here we again specify a constant profile using Dz_lin.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"using ComponentArrays\n# ω not specified\npar_new = ComponentVector(k_Y = 1/10, Y0 = 80.0, i_Y = 10.0,  i_Y_agr = [2.0, 50.0]) \n#\nzs = get_1d_grid(prob)\nstate_pos = get_1d_state_pos(prob)\nu0 = ComponentVector(Y = Dz_lin.(zs[state_pos], z_m) * par_new.Y0)\n\nparopt = ComponentVector(state = u0, par = par_new)\npset = ODEProblemParSetter(get_system(prob), paropt)\nprob2 = remake(prob, paropt, pset)\nnothing # hide","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"We can check the new parameters","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"label_par(pset, prob2.p)[keys(par_new)] == par_new\nlabel_state(pset, prob2.u0)[keys(u0)] == u0","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"And solve the problem and display the results.","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"sol = solve(prob2, Rodas5P(); tstops=[80.0]); \nnothing # hide","category":"page"},{"location":"pde/","page":"PDE support","title":"PDE support","text":"using Plots # hide\nY_ex = extrema(sol[Y(t,z)]) # hide\nanim = @animate for (i_t, t_i) in enumerate(sol[t]) # hide\n    Plots.plot(sol[Y(t,z)][i_t,:], sol[z], xlim=Y_ex, xlab=\"Y(z)\", ylab=\"z (m)\",  # hide\n    title=\"t = $(round(t_i;sigdigits=2))\", # hide\n    yflip=true, # hide\n    ) # hide\nend; # hide\ngif(anim, fps=3) # hide","category":"page"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"problemupdater/#ProblemUpdater","page":"ProblemUpdater","title":"ProblemUpdater","text":"","category":"section"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"ProblemUpdater\nget_ode_problemupdater\nNullProblemUpdater","category":"page"},{"location":"problemupdater/#MTKHelpers.ProblemUpdater","page":"ProblemUpdater","title":"MTKHelpers.ProblemUpdater","text":"ProblemUpdater(par_getter, par_setter)\n\nEncapsulates updating an AbstractODEProblem based on the problem itself by  Callable (pu::ProblemUpdater)(prob).\n\nMust be initialized with a callable AbstractProblemParGetter,  e.g. KeysProblemParGetter and on a AbstractODEProblemParSetter, e.g. ODEProblemParSetter.\n\nThere are special functions to construct ProblemUpdater based on a given Problem:\n\nget_ode_problemupdater\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#MTKHelpers.get_ode_problemupdater","page":"ProblemUpdater","title":"MTKHelpers.get_ode_problemupdater","text":"get_ode_problemupdater(par_getter::AbstractProblemParGetter, u0, p)\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, sys::AbstractODESystem)\n\nConstruct a ProblemUpdater based on an constructed ODEProblemParSetterConcrete.     \n\n\n\n\n\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, u0, p)\nget_ode_problemupdater(par_getter::AbstractProblemParGetter, sys::AbstractODESystem)\n\nConstruct a ProblemUpdater based on an constructed ODEProblemParSetterConcrete.     \n\n\n\n\n\n","category":"function"},{"location":"problemupdater/#MTKHelpers.NullProblemUpdater","page":"ProblemUpdater","title":"MTKHelpers.NullProblemUpdater","text":"AbstractProblemUpdater that returns the original AbstractODEProblem.\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#ProblemParGetter","page":"ProblemUpdater","title":"ProblemParGetter","text":"","category":"section"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"In order to provide computations for parameters to set, declare a concrete subtype of AbstractProblemParGetter, and implement a custom  method (pg::MyProblemParGetter)(pu::ProblemUpdater, prob) that returns a vector of parameter values. ","category":"page"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"AbstractProblemParGetter","category":"page"},{"location":"problemupdater/#MTKHelpers.AbstractProblemParGetter","page":"ProblemUpdater","title":"MTKHelpers.AbstractProblemParGetter","text":"Supertype for callables that implement      (::AbstractProblemParGetter)(problem) -> updated_problem\n\nConcrete subtypes should implement function keys, so that an appropriate  AbstractODEProblemParSetter can be constructed for ProblemUpdater.\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"One simple subtype of AbstractProblemParGetter is KeysProblemParGetter,  which just extracts variables from the  original problem to update other parameters. It can be used to ensure that some parameter of a problem will always equal  another parameter of the problem. ","category":"page"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"KeysProblemParGetter","category":"page"},{"location":"problemupdater/#MTKHelpers.KeysProblemParGetter","page":"ProblemUpdater","title":"MTKHelpers.KeysProblemParGetter","text":"KeysProblemParGetter(mapping::NTuple{N,Pair{Symbol, Symbol}, keys_state)\n\nProvices callable (pg::KeysProblemParGetter)(pu::ProblemUpdater, prob), keys_state].     To be used to get the parameters/state vector to be set by ProblemUpdater.\n\nInitialize with an mapping of NTuples of symbols (source -> target) that index into  either label_state(pu.pset, prob.u0) or label_par(pu.pset, prob.p)). Argument keys_state is a Tuple or Vector that iterates the Symbols in the state of an  ODEProblem. It is required to know from which part of the problem to extract.\n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#ProblemParSetter","page":"ProblemUpdater","title":"ProblemParSetter","text":"","category":"section"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"AbstractProblemParSetter","category":"page"},{"location":"problemupdater/#MTKHelpers.AbstractProblemParSetter","page":"ProblemUpdater","title":"MTKHelpers.AbstractProblemParSetter","text":"During an optimization, one does not want to recreate the problem from a symbolic system, but only update the problem. This can be difficult, because the parameters to update may be spread across initial state and other parameters.  Further, the order of parameters after simplifying a system is not fixed.\n\nA AbstractProblemUpdater helps with \n\nremake: translate the set of parameters -> an updated problem \nget_paropt: problem -> extract/approximate subset of parameters to optimize \n\nThe structure of optimized parameter Vector is described by an Axis object  of ComponentArrays.jl. And several functions are defined to work with it. Specifically, the ComponentVector it employs a classification (classes_paropt), ,e.g. :state and :par for ODEProblems, below which, ComponentVectors of actual parameters are listed (keys_paropt](@ref)). Further functions extract information about the ComponentVector: axis_paropt, , count_paropt,  symbols_paropt or attach information to a plain vector for convenient access or display: label_paropt, name_paropt. \n\n\n\n\n\n","category":"type"},{"location":"problemupdater/#Translating-between-parameters-and-Problem","page":"ProblemUpdater","title":"Translating between parameters and Problem","text":"","category":"section"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"remake(::SciMLBase.AbstractSciMLProblem, popt, pset::AbstractProblemParSetter)\nget_paropt(pset::AbstractProblemParSetter, prob::SciMLBase.AbstractSciMLProblem)","category":"page"},{"location":"problemupdater/#SciMLBase.remake-Tuple{SciMLBase.AbstractSciMLProblem, Any, AbstractProblemParSetter}","page":"ProblemUpdater","title":"SciMLBase.remake","text":"remake(prob::AbstractSciMLProblem, popt, ps::AbstractProblemParSetter)\n\nReturn an updated problem given the parameters. Subtypes need to implement method remake_pset(prob, popt, pset)\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.get_paropt-Tuple{AbstractProblemParSetter, SciMLBase.AbstractSciMLProblem}","page":"ProblemUpdater","title":"MTKHelpers.get_paropt","text":"get_paropt(pset::AbstractProblemParSetter, prob::SciMLBase.AbstractSciMLProblem; kwargs...)\nget_paropt_labeled(pset::AbstractProblemParSetter, prob::SciMLBase.AbstractSciMLProblem; kwargs...)\n\nExtract optimized parameters from the Problem. The labeled versions additionally calls label_paropt on the return value.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#Helper-functions-to-access-optimized-parameters","page":"ProblemUpdater","title":"Helper functions to access optimized parameters","text":"","category":"section"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"axis_paropt(::AbstractProblemParSetter)\nclasses_paropt(::AbstractProblemParSetter)\ncount_paropt(pset::AbstractProblemParSetter) \nkeys_paropt(ps::AbstractProblemParSetter) \nsymbols_paropt(pset::AbstractProblemParSetter)","category":"page"},{"location":"problemupdater/#MTKHelpers.axis_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.axis_paropt","text":"axis_paropt(pset::AbstractProblemParSetter)\n\nReport the Axis of a CompoenentVector of parameters.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.classes_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.classes_paropt","text":"function classes_paropt(pset::AbstractProblemParSetter)\n\nGet the classes (as NTuple{Symbol}) which the AbstractProblemParSetter  supports and requires in paropt.        \n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.count_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.count_paropt","text":"count_paropt(::AbstractProblemParSetter)\n\nReport length of the optimized parameters vector.     This generally is different from the length of keys, because each key can describe a array.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.keys_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.keys_paropt","text":"keys_paropt(::AbstractProblemParSetter)\n\nReport the keys of paropt below the classification level.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.symbols_paropt-Tuple{AbstractProblemParSetter}","page":"ProblemUpdater","title":"MTKHelpers.symbols_paropt","text":"symbols_paropt(pset::AbstractProblemParSetter)\n\nReport the names, i.e. symbols of optimiz parameters respectively,  i.e. the concatenation of components. Similar to ComponentArrays.label, but inferred from Axis object.   Returns a Vector of length count_paropt\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#Labeling-parameter-vectors","page":"ProblemUpdater","title":"Labeling parameter vectors","text":"","category":"section"},{"location":"problemupdater/","page":"ProblemUpdater","title":"ProblemUpdater","text":"label_paropt(pset::AbstractProblemParSetter, popt)\nname_paropt(pset::AbstractProblemParSetter, paropt::AbstractVector)","category":"page"},{"location":"problemupdater/#MTKHelpers.label_paropt-Tuple{AbstractProblemParSetter, Any}","page":"ProblemUpdater","title":"MTKHelpers.label_paropt","text":"label_paropt(pset::AbstractProblemParSetter, popt::AbstractVector)\n\nProduce a labeled version, i.e. a ComponentVector of optimized parameters.\n\n\n\n\n\n","category":"method"},{"location":"problemupdater/#MTKHelpers.name_paropt-Tuple{AbstractProblemParSetter, AbstractVector}","page":"ProblemUpdater","title":"MTKHelpers.name_paropt","text":"name_paropt(pset, popt::AbstractVector) \nname_paropt(pset, prob::AbstractSciMLProblem)\n\nProduce a NamedVector of given state optimized parameters vector. Similar to label_paropt, but may print nicer. The second form calls get_paropt on the Problem.\n\n\n\n\n\n","category":"method"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"updating_problems/#Setting-Initial-state-and-Parameters-of-a-problem","page":"Updating problems","title":"Setting Initial state and Parameters of a problem","text":"","category":"section"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Often one wants to change a subset of the initial states,u0, and a subset of parameters,p, of an AbstractODEProblem during an optimization.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Given u0 and p can be expressed as ComponentVectors,  and popt can be expressed as a ComponentVector of optimized parameters,  which may include initial states. The initial states and parameter components  must have different names.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"The following example system employs a scalar and a vector-valued parameter.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"using ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nfunction samplesystem(;name,τ = 3.0, p=[1.1, 1.2]) \n    @variables t \n    D = Differential(t) \n    sts = @variables x(t) RHS(t)        # RHS is observed\n    ps = @parameters τ=τ p[1:2] = p \n    ODESystem([ RHS  ~ p[1] + -p[2]*x + (1 - x)/τ, D(x) ~ RHS ], t, sts, vcat(ps...); name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0))\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"An ODEProblemParSetter then can be used to update a subset of states and parameters in the derived problem.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"# setup position matching, note τ is not in parameters optimized\npopt = ComponentVector(state=(m₊x=0.1,), par=(m₊p=[2.1,2.2],)) \npset = ODEProblemParSetter(sys, popt) # pass through function barrier to use type inference\n\n# extract optimized \nget_paropt(pset, prob)          # plain vector\nget_paropt_labeled(pset, prob)  # ComponentVector\nname_paropt(pset, prob)         # NamedVector \n\n# update states and parameters\nprob2 = remake(prob, popt, pset)\nprob2.p # p is still a plain vector\nlabel_par(pset, prob2.p).m₊p == popt.par.m₊p # attach labels and access properties\nlabel_state(pset, prob2.u0).m₊x == popt.state.m₊x # attach labels and access properties\nget_paropt_labeled(pset, prob2) == popt\nnothing # hide","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"Note that produced labeled CompoenentArrays are not fully type-inferred, unless a concrete versions of the ParameterSetter and function barriers are used as described  in Concrete ProblemUpdater.","category":"page"},{"location":"updating_problems/#ProblemUpdater","page":"Updating problems","title":"ProblemUpdater","text":"","category":"section"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"A ODEProblemParSetterConcrete can be combined with a KeysProblemParGetter or other specific implementations of AbstractProblemParGetter to  update an AbstractODEProblem based on information already present in the AbstractODEProblem.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"The following example updates parameters k_R and k_P in the AbstractODEProblem to the value of k_L. This can be useful to ensure that these parameters are also changed when optimizing parameter k_L.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"An implementations of AbstractProblemParGetter can use any computation of the source keys to provide its destination keys. It should implement the keys method, so that when constructing the ProblemUpdater, consistent keys are used, as in the example below.","category":"page"},{"location":"updating_problems/","page":"Updating problems","title":"Updating problems","text":"using ModelingToolkit, OrdinaryDiffEq, ComponentArrays\nusing MTKHelpers\nf = (u,p,t) -> p[1]*u\nu0 = ComponentVector(L=1/2)\np = ComponentVector(k_L = 1.0, k_R = [2.0,3.0], k_P = [4.0,5.0], k_L2 = 6.0)\ntspan = (0.,1.)\nprob = ODEProblem(f,getdata(u0),tspan,getdata(p))\n#\nmapping = (:k_L => :k_L2, :k_R => :k_P)\npu = get_ode_problemupdater(KeysProblemParGetter(mapping, keys(u0)), u0, p)\n#axis_par(par_setter(pu))\nprob2 = pu(prob)\np2 = label_par(par_setter(pu), prob2.p)\np2.k_P == p.k_R\np2.k_L2 == p.k_L\nnothing # hide","category":"page"},{"location":"zindex/","page":"index","title":"index","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"zindex/#Index","page":"index","title":"Index","text":"","category":"section"},{"location":"zindex/","page":"index","title":"index","text":"","category":"page"},{"location":"smoothstep/","page":"Smooth steps","title":"Smooth steps","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"smoothstep/#Smooth-steps","page":"Smooth steps","title":"Smooth steps","text":"","category":"section"},{"location":"smoothstep/","page":"Smooth steps","title":"Smooth steps","text":"ODE solvers have a hard time with step changes, where the derivative changes discontinuously. The following function help to avoid associated problems by approximating the step by a smoother function. Argument dx controls the  smoothness.","category":"page"},{"location":"smoothstep/","page":"Smooth steps","title":"Smooth steps","text":"smoothstep","category":"page"},{"location":"smoothstep/#MTKHelpers.smoothstep","page":"Smooth steps","title":"MTKHelpers.smoothstep","text":"smoothstep(x, x_step, dx, a=zero(x), b=one(x))\n\nsmooth step function: \n\n= a for x <= x_step - dx\n= b for x >= x_step + dx\n= (a-b)/2 for x == x_step\n\nand smooth in between.\n\n\n\n\n\n","category":"function"},{"location":"solution/","page":"Solution handling","title":"Solution handling","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"solution/#Indexing-into-the-solution","page":"Solution handling","title":"Indexing into the solution","text":"","category":"section"},{"location":"solution/","page":"Solution handling","title":"Solution handling","text":"getlast","category":"page"},{"location":"solution/#MTKHelpers.getlast","page":"Solution handling","title":"MTKHelpers.getlast","text":"getlast(sol, vars...)\ngetlast(sol, vars_vec)\n\nApply getindex for each var to sol and return a NamedArray.\n\nusing ModelingToolkit, OrdinaryDiffEq\nusing MTKHelpers\nusing NamedArrays\nfunction samplesystem(;name) \n    @variables t \n    D = Differential(t) \n    sts = @variables x(t) RHS(t)  # RHS is observed\n    ps = @parameters τ       # parameters\n    ODESystem([ RHS  ~ (1 - x)/τ, D(x) ~ RHS ], t, sts, ps; name)\nend                     \n@named m = samplesystem()\n@named sys = embed_system(m)\nprob = ODEProblem(sys, [m.x => 0.0], (0.0,10.0), [m.τ => 3.0])\nsol = solve(prob, Tsit5());\nres = getlast(sol, m.x, m.RHS)\nres == NamedArray([sol[m.x,end], sol[m.RHS,end]], ([m.x, m.RHS],))   \n# output\ntrue\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"#MTKHelpers","page":"Home","title":"MTKHelpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MTKHelpers.","category":"page"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"CurrentModule = MTKHelpers","category":"page"},{"location":"odeproblemparsetter/#AbstractODEProblemParSetter","page":"ODEProblem","title":"AbstractODEProblemParSetter","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"The following type implements Translating between parameters and Problem for AbstractODEProblems.","category":"page"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"AbstractODEProblemParSetter","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.AbstractODEProblemParSetter","page":"ODEProblem","title":"MTKHelpers.AbstractODEProblemParSetter","text":"Support translation between parameter vectors and  AbstractODEProblem.\n\nTakes care of mapping optimized parameters to subset of\n\nstate u0, and\nparameters p\n\nIn addition to the AbstractProblemParSetter functions, which accessing and labelling parameter vectors, it provides functions that access and label problem state and  parameters: axis_state, count_state,  keys_state, symbols_state, label_state,  name_state\n\n\n\n\n\n","category":"type"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"See the specific implementation ODEProblemParSetter. ","category":"page"},{"location":"odeproblemparsetter/#Helper-functions-to-access-state-and-parameters","page":"ODEProblem","title":"Helper functions to access state and parameters","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"axis_state\nkeys_state\ncount_state\nsymbols_state","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.axis_state","page":"ODEProblem","title":"MTKHelpers.axis_state","text":"axis_state(pset::AbstractODEProblemParSetter)\naxis_par(pset::AbstractODEProblemParSetter)\n\nReport the Axis, i.e. nested component symbols of problem states, and problem parameters respectively. Returns an AbstractAxis.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.keys_state","page":"ODEProblem","title":"MTKHelpers.keys_state","text":"keys_state(::AbstractODEProblemParSetter) \nkeys_par(::AbstractODEProblemParSetter)\n\nReport the keys problem states, problem parameters.  This usually correspdonds to keys(axis), but if there is a classification, similar to keys_paropt, report the keys below this classification.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.count_state","page":"ODEProblem","title":"MTKHelpers.count_state","text":"count_state(::AbstractODEProblemParSetter) \ncount_par(::AbstractODEProblemParSetter)\n\nReport the number of problem states, problem parameters and optimized parameters respectively.    \n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#MTKHelpers.symbols_state","page":"ODEProblem","title":"MTKHelpers.symbols_state","text":"symbols_state(sys::ODESystem)\nsymbols_par(sys::ODESystem)\n\nExtract the basic symbols without namespace of system states and system parameters.\n\n\n\n\n\nsymbols_state(pset::AbstractODEProblemParSetter)\nsymbols_par(pset::AbstractODEProblemParSetter)\nsymbols_paropt(pset::AbstractODEProblemParSetter)\n\nReport the names, i.e. symbols of problem states, problem parameters respectively, i.e. the concatenation of components. Similar to ComponentArrays.label, but inferred from Axis object.   \n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#Labeling","page":"ODEProblem","title":"Labeling","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"label_state(::AbstractODEProblemParSetter, u0)\nname_state(::AbstractODEProblemParSetter, state::AbstractVector)","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.label_state-Tuple{AbstractODEProblemParSetter, Any}","page":"ODEProblem","title":"MTKHelpers.label_state","text":"label_state(pset::AbstractODEProblemParSetter, u::AbstractVector) \nlabel_par(pset::AbstractODEProblemParSetter, par::AbstractVector)\n\nProduce a labeled version, i.e. a ComponentVector of initial states, parameters  respectively.\n\n\n\n\n\n","category":"method"},{"location":"odeproblemparsetter/#MTKHelpers.name_state-Tuple{AbstractODEProblemParSetter, AbstractVector}","page":"ODEProblem","title":"MTKHelpers.name_state","text":"name_state(pset, u::AbstractVector) \nname_par(pset, par::AbstractVector)\n\nProduce a NamedVector of given state, parameters, or optimized vars.\n\n\n\n\n\n","category":"method"},{"location":"odeproblemparsetter/#Setting-entire-state-and-parameter-vectors","page":"ODEProblem","title":"Setting entire state and parameter vectors","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"get_u_map","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.get_u_map","page":"ODEProblem","title":"MTKHelpers.get_u_map","text":"get_u_map(u_new, pset::AbstractODEProblemParSetter)\nget_p_map(p_new, pset::AbstractODEProblemParSetter)\n\nMap each state and parameter the AbstractODEProblemParSetter pset to a position in names.\n\nWhen construction an AbstractODEProblem from a ODESystem, the order of states and  parameters may have changed compared with a previous construction.\n\nIn order to set entire state or parameter vectors, a mapping from current to previous positions, i.e. integer indices, is required,  so that one can get a vectors in the new format by \n\nu0_old[u_map] .= u_new\np_old[p_map] .= p_new\n\nu_new can be anything for which an axis can be extracted, whose keys are used. Specifically it can be the ComponentVector of new states itself, or a vector of symbols.\n\nKeyword arguments\n\nis_warn_missing: set to true to issue warnings if some ODESystem state or  parameter names are not found in the old names. This may give false warnings for System parameters that have defaults and do not need to be part of the parameter vector.\n\n\n\n\n\n","category":"function"},{"location":"odeproblemparsetter/#ODEProblemParSetter","page":"ODEProblem","title":"ODEProblemParSetter","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"ODEProblemParSetter","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.ODEProblemParSetter","page":"ODEProblem","title":"MTKHelpers.ODEProblemParSetter","text":"ODEProblemParSetter(state_template,par_template,popt_template) \nODEProblemParSetter(sys::ODESystem, popt_template)\n\nHelps keeping track of a subset of initial states and parameters to be optimized.\n\nArguments\n\nstate_template: ComponentVector or Axis of all the initial states of the problem\npar_template: all the parameters of the problem\npopt_template: the parameter/initial states to be optimized.  If given as Tuple or AbstractVector of symbols, then a template ComponentVector is extracted from state_template and par_template.\n\nIf all of state_template, par_template, and popt_template are type-inferred Axes, then also the constructed ODEProblemParSetter is type-inferred.\n\nThe states and parameters can be extracted from an ModelingToolkit.ODESystem.\n\nNote the similar ODEProblemParSetterConcrete with template parameters, which  supports type-stable calls (see Concrete ProblemUpdater).\n\n\n\n\n\n","category":"type"},{"location":"odeproblemparsetter/#ODEProblemParSetterConcrete","page":"ODEProblem","title":"ODEProblemParSetterConcrete","text":"","category":"section"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"To support Concrete ProblemUpdater the following variant of  ODEProblemParSetter is provided.","category":"page"},{"location":"odeproblemparsetter/","page":"ODEProblem","title":"ODEProblem","text":"ODEProblemParSetterConcrete","category":"page"},{"location":"odeproblemparsetter/#MTKHelpers.ODEProblemParSetterConcrete","page":"ODEProblem","title":"MTKHelpers.ODEProblemParSetterConcrete","text":"ODEProblemParSetterConcrete(state_template,par_template,popt_template) \nODEProblemParSetterConcrete(sys::ODESystem, popt_template)\n\nHelps keeping track of a subset of initial states and parameters to be optimized. Similar to ODEProblemParSetter, but with axis and length information as type parameters. `\n\n\n\n\n\n","category":"type"}]
}
